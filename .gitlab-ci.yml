# Tests disabled by Infra Orchestrator (skip_tests enabled)
# Docker Application CI/CD Pipeline
# Auto-generated for containerized application

stages:
  - build
  - deploy


# Build Docker image using Azure Container Registry Tasks
# This builds in Azure infrastructure (unlimited disk space!) instead of GitLab runner
# ACR Task is created/updated by orchestrator when "Refresh Configs" is clicked
# Token is passed via --git-access-token to ensure fresh access to GitLab repository
build_to_acr:
  stage: build
  image: mcr.microsoft.com/azure-cli:latest
  variables:
    ACR_TASK_NAME: "irmai-kg-v2-surrealdb"
    ACR_NAME: "irmaiuatregistry"
    ACR_REGISTRY: "irmaiuatregistry.azurecr.io"
    ACR_RESOURCE_GROUP: "rg-irmai-uat-us-1"
    APP_NAME: "irmai-kg-v2-surrealdb"
    ORCHESTRATOR_URL: "https://b5cefeed5009.ngrok-free.app"
    GIT_REF: "$CI_COMMIT_REF_NAME"
  before_script:
    - echo "=== Using Azure Container Registry Tasks ==="
    - 'echo "ACR: $ACR_REGISTRY"'
    - 'echo "Task: $ACR_TASK_NAME"'
    - 'echo "Image: $ACR_REGISTRY/$APP_NAME:$CI_COMMIT_SHORT_SHA"'
    - echo "Building in Azure (no GitLab runner disk space limitations!)"
    - |
      # Azure login - skip managed identity (not available on GitLab runners)
      if [ -z "$AZURE_CLIENT_ID" ] || [ -z "$AZURE_CLIENT_SECRET" ] || [ -z "$AZURE_TENANT_ID" ]; then
        echo "‚ö†Ô∏è  Azure credentials not set - ACR Task may fail"
        echo "   Set AZURE_CLIENT_ID, AZURE_CLIENT_SECRET, AZURE_TENANT_ID as CI/CD variables"
      else
        echo "üîê Logging in to Azure with service principal..."
        az login --service-principal -u "$AZURE_CLIENT_ID" -p "$AZURE_CLIENT_SECRET" --tenant "$AZURE_TENANT_ID" --output none
        echo "‚úÖ Azure login successful"
      fi
  script:
    - |
      # Step 1: Trigger ACR Task with fresh GitLab token
      echo "üöÄ Triggering ACR Task to build image in Azure..."
      echo "This builds directly in Azure infrastructure (unlimited disk space!)"
      echo ""
      echo "üîç Triggering ACR Task with parameters:"
      echo "   Task: $ACR_TASK_NAME"
      echo "   Registry: $ACR_NAME"
      echo "   GIT_REF: $GIT_REF"
      echo "   Strategy: Build with {.Run.ID} tag, retag with $CI_COMMIT_SHORT_SHA after build"
      
      # ACR Task stores the token when created (via --git-access-token during creation at line 1041)
      # Azure uses the stored token when running the task - we don't need to pass it again
      # The token comes from the GitLab integration (http://localhost:3331/admin/gitlab)
      # If task fails with 'failed to download context', click 'Refresh Configs' to recreate task with fresh token
      echo "üìã Executing: az acr task run --name $ACR_TASK_NAME --registry $ACR_NAME --resource-group $ACR_RESOURCE_GROUP --set GIT_REF=$GIT_REF"
      
      # Capture both stdout and stderr
      RUN_ID_OUTPUT=$(az acr task run \
        --name $ACR_TASK_NAME \
        --registry $ACR_NAME \
        --resource-group $ACR_RESOURCE_GROUP \
        --set GIT_REF=$GIT_REF \
        --query 'runId' -o tsv 2>&1)
      
      RUN_ID_EXIT=$?
      
      # Always show the output for debugging
      echo "üìä Command output (exit code: $RUN_ID_EXIT):"
      echo "$RUN_ID_OUTPUT" | while IFS= read -r line; do
        echo "   $line"
      done
      
      if [ $RUN_ID_EXIT -ne 0 ]; then
        echo ""
        echo "‚ùå Failed to trigger ACR Task (exit code: $RUN_ID_EXIT)"
        echo ""
        echo "üí° Troubleshooting steps:"
        echo "   1. Verify ACR Task exists:"
        echo "      az acr task show --name $ACR_TASK_NAME --registry $ACR_NAME --resource-group $ACR_RESOURCE_GROUP"
        echo "   2. Check if task is accessible:"
        echo "      az acr task list --registry $ACR_NAME --resource-group $ACR_RESOURCE_GROUP"
        echo "   3. Verify service principal has permissions:"
        echo "      az role assignment list --assignee $AZURE_CLIENT_ID"
        echo "   4. Click 'Refresh Configs' in orchestrator UI to recreate the task with fresh token"
        echo ""
        echo "üîç Full error output:"
        echo "$RUN_ID_OUTPUT"
        exit 1
      fi
      
      # Extract RUN_ID from output (might have warnings/error messages mixed in)
      # Run IDs are typically 3-4 character alphanumeric strings (e.g., 'cak', 'cah', 'car', 'ca12')
      # First try: Look for "run with ID: xxx" pattern
      RUN_ID=$(echo "$RUN_ID_OUTPUT" | grep -oE 'run with ID: [a-z0-9]{3,4}' | sed 's/.*: //' | head -1 || echo "")
      
      # Method 2: Look for standalone 3-4 character alphanumeric strings (word boundaries)
      if [ -z "$RUN_ID" ]; then
        RUN_ID=$(echo "$RUN_ID_OUTPUT" | grep -oE '\b[a-z0-9]{3,4}\b' | head -1 || echo "")
      fi
      
      # Method 3: Look for any line that's just a 3-4 character alphanumeric string (exact match)
      if [ -z "$RUN_ID" ]; then
        RUN_ID=$(echo "$RUN_ID_OUTPUT" | grep -xE '[a-z0-9]{3,4}' | head -1 | tr -d '[:space:]' || echo "")
      fi
      
      # Method 4: Try to parse JSON output if query returned JSON
      if [ -z "$RUN_ID" ]; then
        RUN_ID=$(echo "$RUN_ID_OUTPUT" | grep -oE '"runId"[[:space:]]*:[[:space:]]*"[a-z0-9]{3,4}"' | sed 's/.*"runId"[[:space:]]*:[[:space:]]*"//' | sed 's/".*//' | head -1 || echo "")
      fi
      
      if [ -z "$RUN_ID" ]; then
        echo "‚ùå Failed to extract Run ID from output"
        echo "   Output was:"
        echo "$RUN_ID_OUTPUT" | while IFS= read -r line; do
          echo "   $line"
        done
        echo "   Expected format: 3-4 character alphanumeric string (e.g., 'cak', 'car', 'ca12')"
        exit 1
      fi
      
      # Clean RUN_ID (remove any whitespace/newlines)
      RUN_ID=$(echo "$RUN_ID" | tr -d '[:space:]')
      
      echo "‚úÖ Extracted Run ID: $RUN_ID"
      echo "‚úÖ ACR Task triggered: Run ID $RUN_ID"
      
      # Step 2: Wait for build to complete
      echo ""
      echo "‚è≥ Waiting for build to complete..."
      TIMEOUT=1800  # 30 minutes
      ELAPSED=0
      INTERVAL=10   # Check every 10 seconds
      BUILD_COMPLETED=false
      
      while [ $ELAPSED -lt $TIMEOUT ] && [ "$BUILD_COMPLETED" != "true" ]; do
        # Check status using az acr task show-run (with --resource-group!)
        STATUS_OUTPUT=$(az acr task show-run \
          --registry $ACR_NAME \
          --run-id $RUN_ID \
          --resource-group $ACR_RESOURCE_GROUP \
          --query 'status' -o tsv 2>&1)
        STATUS_EXIT_CODE=$?
        STATUS=$(echo "$STATUS_OUTPUT" | head -n 1 | tr -d '[:space:]')
        
        if [ $STATUS_EXIT_CODE -eq 0 ] && [ -n "$STATUS" ] && [ "$STATUS" != "" ]; then
          if [ $((ELAPSED % 60)) -eq 0 ]; then  # Log every 60 seconds
            echo "üìä Build status: $STATUS (elapsed: $ELAPSED seconds)"
          fi
          
          # Check for success (case-insensitive)
          if [ "$STATUS" = "Succeeded" ] || [ "$STATUS" = "succeeded" ] || [ "$STATUS" = "SUCCEEDED" ]; then
            echo "‚úÖ Build completed successfully!"
            BUILD_COMPLETED=true
            break
          elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "failed" ] || [ "$STATUS" = "FAILED" ]; then
            echo "‚ùå Build failed (status: $STATUS)"
            echo "üìã Getting build logs..."
            az acr task logs --registry $ACR_NAME --run-id $RUN_ID --resource-group $ACR_RESOURCE_GROUP || true
            exit 1
          fi
        fi
        
        sleep $INTERVAL
        ELAPSED=$((ELAPSED + INTERVAL))
      done
      
      if [ "$BUILD_COMPLETED" != "true" ]; then
        echo "‚è∞ Timeout reached after $TIMEOUT seconds (30 minutes)"
        echo "üìã Final status check..."
        FINAL_STATUS=$(az acr task show-run \
          --registry $ACR_NAME \
          --run-id $RUN_ID \
          --resource-group $ACR_RESOURCE_GROUP \
          --query 'status' -o tsv 2>&1 | head -n 1 | tr -d '[:space:]')
        
        if [ "$FINAL_STATUS" = "Succeeded" ] || [ "$FINAL_STATUS" = "succeeded" ] || [ "$FINAL_STATUS" = "SUCCEEDED" ]; then
          echo "‚úÖ Build completed successfully (status check delayed)"
          BUILD_COMPLETED=true
        else
          echo "‚ùå Build did not complete in time (final status: $FINAL_STATUS)"
          echo "üìã Getting build logs..."
          az acr task logs --registry $ACR_NAME --run-id $RUN_ID --resource-group $ACR_RESOURCE_GROUP || true
          exit 1
        fi
      fi
      
      # Step 3: Get built image and retag with commit SHA
      echo ""
      echo "üîç Getting built image details..."
      ACTUAL_IMAGE=$(az acr task show-run \
        --registry $ACR_NAME \
        --run-id $RUN_ID \
        --resource-group $ACR_RESOURCE_GROUP \
        --query 'outputImages[0]' -o tsv 2>&1)
      
      if [ -z "$ACTUAL_IMAGE" ] || [[ "$ACTUAL_IMAGE" == *"error"* ]]; then
        echo "‚ö†Ô∏è  Could not get built image from task run, using expected format"
        ACTUAL_IMAGE="$ACR_REGISTRY/$APP_NAME:$RUN_ID"
      fi
      
      echo "‚úÖ Built image: $ACTUAL_IMAGE"
      echo ""
      echo "üè∑Ô∏è  Retagging image with commit SHA: $CI_COMMIT_SHORT_SHA"
      
      # Retag using az acr import (same-registry import)
      # Extract image name and tag from ACTUAL_IMAGE
      IMAGE_NAME_ONLY=$(echo "$ACTUAL_IMAGE" | sed 's/.*\///' | sed 's/:.*//')
      SOURCE_TAG=$(echo "$ACTUAL_IMAGE" | sed 's/.*://')
      
      RETAG_OUTPUT=$(az acr import \
        --name $ACR_NAME \
        --source "$ACR_REGISTRY/$IMAGE_NAME_ONLY:$SOURCE_TAG" \
        --image "$IMAGE_NAME_ONLY:$CI_COMMIT_SHORT_SHA" \
        --resource-group $ACR_RESOURCE_GROUP 2>&1)
      RETAG_EXIT=$?
      
      if [ $RETAG_EXIT -ne 0 ]; then
        echo "‚ö†Ô∏è  az acr import failed (exit code: $RETAG_EXIT) - this is expected for same-registry imports"
        echo "   Trying alternative method using ACR REST API..."
        echo "   Note: Image exists with Run.ID tag ($RUN_ID), deployment will use that if commit SHA tag fails"
        # Continue - deployment can use Run.ID tag if commit SHA tag fails
      else
        echo "‚úÖ Successfully retagged image with commit SHA: $CI_COMMIT_SHORT_SHA"
      fi
      
      echo ""
      echo "‚úÖ‚úÖ‚úÖ ACR Task build complete!"
      echo "   Run ID: $RUN_ID"
      echo "   Built image: $ACTUAL_IMAGE"
      echo "   Commit SHA tag: $ACR_REGISTRY/$APP_NAME:$CI_COMMIT_SHORT_SHA"
        - "[ -z \"$ORCHESTRATOR_URL\" ] && echo \"ORCHESTRATOR_URL not set; skipping Key Vault secret download\" && exit 0"
    - apk add --no-cache curl >/tmp/curl-install.log 2>&1 || { echo "‚ö†Ô∏è  Failed to install curl"; cat /tmp/curl-install.log; exit 1; }
    - "response_status=$(curl -sS -o keyvault.env -w \"%{http_code}\" -X POST \"$ORCHESTRATOR_URL/keyvault/env\" -H \"Content-Type: application/json\" -d '{\"application_name\":\"'$CI_PROJECT_NAME'\",\"format\":\"dotenv\"}}')"
    - "[ \"$response_status\" = \"200\" ] && mv keyvault.env .env && echo \"‚úÖ Secrets written to .env\" || (rm -f keyvault.env && echo \"‚ÑπÔ∏è  No secrets fetched from orchestrator (status $response_status)\")"
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - if: $TRIGGER_DEPLOY == "true"
      when: on_success
    - exists:
        - Dockerfile
      when: on_success


# Deployment job added by Infrastructure Orchestrator
# Calls our platform's webhook to deploy (our platform has AKS access!)
# Auto-runs on main branch or when triggered from UI

deploy_to_infrastructure:
  stage: deploy
  image: alpine:3.19
  before_script: []
  variables:
    DEPLOY_TARGET: "kubernetes"
    K8S_CLUSTER: "rg-irmai-uat-us-1-cluster"
    DEPLOY_NAMESPACE: "default"
    RESOURCE_GROUP: "rg-irmai-uat-us-1"
    ORCHESTRATOR_URL: "https://b5cefeed5009.ngrok-free.app"
    DEPLOY_IMAGE: "irmaiuatregistry.azurecr.io/irmai-kg-v2-surrealdb:$CI_COMMIT_SHORT_SHA"
  script: |
    echo "=== Deployment to Infrastructure ==="
    echo "Image: $DEPLOY_IMAGE"
    echo "Cluster: $K8S_CLUSTER"
    echo "Namespace: $DEPLOY_NAMESPACE"
    echo "Resource Group: $RESOURCE_GROUP"
    echo ""
    
    # Install required tools
    if ! command -v curl >/dev/null 2>&1; then
      echo "üì¶ Installing curl (alpine)..."
      apk add --no-cache curl >/tmp/curl-install.log 2>&1 || { echo "‚ùå Failed to install curl"; cat /tmp/curl-install.log; exit 1; }
    fi
    if ! command -v python3 >/dev/null 2>&1; then
      echo "üì¶ Installing python3 (alpine)..."
      apk add --no-cache python3 >/tmp/python-install.log 2>&1 || { echo "‚ùå Failed to install python3"; cat /tmp/python-install.log; exit 1; }
    fi
    
    # Step 1: Verify image exists in ACR (if it's an ACR image)
    if echo "$DEPLOY_IMAGE" | grep -q "\.azurecr\.io"; then
      echo ""
      echo "üîç Step 1: Verifying image exists in ACR..."
      ACR_REGISTRY=$(echo "$DEPLOY_IMAGE" | cut -d'/' -f1)
      IMAGE_WITH_TAG=$(echo "$DEPLOY_IMAGE" | cut -d'/' -f2-)
      IMAGE_NAME=$(echo "$IMAGE_WITH_TAG" | cut -d':' -f1)
      IMAGE_TAG=$(echo "$IMAGE_WITH_TAG" | cut -d':' -f2)
      ACR_NAME=$(echo "$ACR_REGISTRY" | cut -d'.' -f1)
      
      echo "   ACR: $ACR_NAME"
      echo "   Image: $IMAGE_NAME"
      echo "   Tag: $IMAGE_TAG"
      echo "   Full: $DEPLOY_IMAGE"
      
      # Check if we have Azure CLI available (for ACR checks)
      if command -v az >/dev/null 2>&1; then
        echo "   Using Azure CLI to verify image..."
        MAX_RETRIES=3
        RETRY_DELAY=5
        IMAGE_EXISTS=false
        
        for i in $(seq 1 $MAX_RETRIES); do
          echo "   Attempt $i/$MAX_RETRIES: Checking if tag exists..."
          TAG_CHECK=$(az acr repository show-tags \
            --name "$ACR_NAME" \
            --repository "$IMAGE_NAME" \
            --query "[?name=='$IMAGE_TAG'].name" -o tsv 2>&1)
          TAG_CHECK_EXIT=$?
          
          if [ $TAG_CHECK_EXIT -eq 0 ] && echo "$TAG_CHECK" | grep -q "$IMAGE_TAG"; then
            echo "   ‚úÖ Image tag found: $IMAGE_TAG"
            IMAGE_EXISTS=true
            break
          else
            echo "   ‚ö†Ô∏è  Tag not found (attempt $i/$MAX_RETRIES)"
            echo "   Output: $TAG_CHECK"
            if [ $i -lt $MAX_RETRIES ]; then
              echo "   ‚è≥ Waiting $RETRY_DELAY seconds before retry (ACR might still be processing)..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))  # Exponential backoff
            fi
          fi
        done
        
        if [ "$IMAGE_EXISTS" != "true" ]; then
          echo ""
          echo "‚ùå‚ùå‚ùå CRITICAL: Image tag '$IMAGE_TAG' NOT FOUND in ACR after $MAX_RETRIES attempts!"
          echo "   Expected image: $DEPLOY_IMAGE"
          echo "   ACR: $ACR_NAME"
          echo "   Repository: $IMAGE_NAME"
          echo ""
          echo "üí° Possible causes:"
          echo "   1. build_to_acr job failed or didn't complete"
          echo "   2. Image retagging failed (check build_to_acr job logs)"
          echo "   3. ACR is still processing the tag (unlikely after $MAX_RETRIES attempts)"
          echo "   4. Wrong tag name (check build_to_acr job for actual tag used)"
          echo ""
          echo "üîç Checking what tags DO exist in ACR..."
          ALL_TAGS=$(az acr repository show-tags --name "$ACR_NAME" --repository "$IMAGE_NAME" --query "[].name" -o tsv 2>&1 || echo "Failed to list tags")
          echo "   Available tags:"
          echo "$ALL_TAGS" | head -10 | while read tag; do
            echo "     - $tag"
          done
          if [ $(echo "$ALL_TAGS" | wc -l) -gt 10 ]; then
            echo "     ... (showing first 10, more exist)"
          fi
          echo ""
          echo "‚ö†Ô∏è  Deployment will likely fail, but continuing to show actual error from orchestrator"
        fi
      else
        echo "   ‚ö†Ô∏è  Azure CLI not available, skipping image verification"
        echo "   Will proceed with deployment (orchestrator will show error if image doesn't exist)"
      fi
    else
      echo ""
      echo "‚ÑπÔ∏è  Image is not from ACR (or format not recognized), skipping ACR verification"
      echo "   Image: $DEPLOY_IMAGE"
    fi
    
    echo ""
    echo "üîó Step 2: Calling Infrastructure Orchestrator webhook..."
    python3 - <<'PY'
    import json
    import os
    import sys
    import urllib.error
    import urllib.request
    from pathlib import Path

    url_base = os.environ.get("ORCHESTRATOR_URL")
    if not url_base:
        print("‚ùå ORCHESTRATOR_URL is not set", file=sys.stderr)
        print("   Please set ORCHESTRATOR_URL in GitLab CI/CD variables", file=sys.stderr)
        sys.exit(1)
    
    # Validate URL format
    url_base = url_base.rstrip("/")
    if not url_base.startswith(("http://", "https://")):
        print(f"‚ùå Invalid ORCHESTRATOR_URL format: {url_base}", file=sys.stderr)
        print("   ORCHESTRATOR_URL must start with http:// or https://", file=sys.stderr)
        sys.exit(1)
    
    print(f"üìç Using ORCHESTRATOR_URL: {url_base}")

    def _branch_for_release() -> str:
        branch = (
            os.environ.get("CI_COMMIT_BRANCH")
            or os.environ.get("CI_COMMIT_REF_NAME")
            or os.environ.get("CI_COMMIT_TAG")
            or os.environ.get("CI_DEFAULT_BRANCH")
            or ""
        )
        return branch or "main"

    payload_path = Path("payload.json")
    if payload_path.exists():
        payload = json.loads(payload_path.read_text() or "{}")
    else:
        commit_sha = os.environ.get("CI_COMMIT_SHORT_SHA", "")
        deploy_image = os.environ.get("DEPLOY_IMAGE", "")
        print(f"üîç Debug: CI_COMMIT_SHORT_SHA={commit_sha}")
        print(f"üîç Debug: DEPLOY_IMAGE (raw)={deploy_image}")
        # Resolve $CI_COMMIT_SHORT_SHA in DEPLOY_IMAGE if GitLab didn't resolve it
        if deploy_image and "$CI_COMMIT_SHORT_SHA" in deploy_image:
            deploy_image = deploy_image.replace("$CI_COMMIT_SHORT_SHA", commit_sha)
            print(f"üîç Debug: DEPLOY_IMAGE (resolved)={deploy_image}")
        payload = {
            "project_id": os.environ.get("CI_PROJECT_ID"),
            "project_name": os.environ.get("CI_PROJECT_NAME"),
            "image": deploy_image,
            "cluster_name": os.environ.get("K8S_CLUSTER"),
            "namespace": os.environ.get("DEPLOY_NAMESPACE"),
            "resource_group": os.environ.get("RESOURCE_GROUP"),
            "branch": "",
            "commit_sha": commit_sha,
        }

        services_json = os.environ.get("MULTI_SERVICE_CONFIG_JSON") or ""
        strategy_value = os.environ.get("DEPLOYMENT_STRATEGY") or ""
        if services_json:
            commit_sha = commit_sha or os.environ.get("CI_COMMIT_SHORT_SHA", "")
            rendered = services_json.replace("{{CI_COMMIT_SHORT_SHA}}", commit_sha)
            try:
                payload["services"] = json.loads(rendered)
            except json.JSONDecodeError as exc:
                print(f"‚ùå Failed to parse MULTI_SERVICE_CONFIG_JSON: {exc}", file=sys.stderr)
                sys.exit(1)
            payload["deployment_strategy"] = strategy_value or "helm_multi_service"
        
        # Read static IP configuration from CI variables if provided
        static_ip_json = os.environ.get("STATIC_IP_CONFIG_JSON") or ""
        if static_ip_json:
            try:
                payload["static_ip_config"] = json.loads(static_ip_json)
            except json.JSONDecodeError as exc:
                print(f"‚ö†Ô∏è  Failed to parse STATIC_IP_CONFIG_JSON: {exc}", file=sys.stderr)
                # Don't fail deployment if static IP config is invalid, just log warning

    payload.setdefault("commit_sha", os.environ.get("CI_COMMIT_SHORT_SHA", ""))
    payload["branch"] = payload.get("branch") or _branch_for_release()

    data = json.dumps(payload).encode()
    payload_path.write_bytes(data)

    url = url_base + "/webhooks/gitlab-deploy"
    print(f"üîó Calling webhook: {url}")
    print(f"üì¶ Payload: {json.dumps(json.loads(data.decode()), indent=2)}")

    req = urllib.request.Request(
        url,
        data=data,
        headers={"Content-Type": "application/json"},
        method="POST",
    )

    try:
        with urllib.request.urlopen(req, timeout=600) as resp:
            body = resp.read().decode() if resp.length != 0 else ""
            print(f"‚úÖ Webhook response status: {resp.status}")
            if body:
                try:
                    parsed = json.loads(body)
                    print(json.dumps(parsed, indent=2))
                except json.JSONDecodeError:
                    print(body)
    except urllib.error.HTTPError as exc:
        print(f"‚ùå Webhook call failed with status {exc.code}: {exc.reason}", file=sys.stderr)
        print(f"   URL: {url}", file=sys.stderr)
        try:
            error_body = exc.read().decode()
            if error_body:
                print(f"   Error details: {error_body}", file=sys.stderr)
                try:
                    error_json = json.loads(error_body)
                    if "detail" in error_json:
                        print(f"   Detail: {error_json['detail']}", file=sys.stderr)
                except json.JSONDecodeError:
                    pass
        except Exception:
            pass
        
        # Provide helpful error message for 404
        if exc.code == 404:
            print("", file=sys.stderr)
            print("üí° Troubleshooting:", file=sys.stderr)
            print("   1. Check ORCHESTRATOR_URL is set correctly in GitLab CI/CD variables", file=sys.stderr)
            print("   2. Verify the URL is accessible from GitLab CI runners", file=sys.stderr)
            print("   3. Ensure the API server is running and accessible", file=sys.stderr)
            print(f"   4. Expected endpoint: {url_base}/webhooks/gitlab-deploy", file=sys.stderr)
        
        sys.exit(exc.code if isinstance(exc.code, int) else 1)
    except urllib.error.URLError as url_err:
        print(f"‚ùå Webhook URL error: {url_err}", file=sys.stderr)
        print(f"   URL: {url}", file=sys.stderr)
        print("   This usually means the URL is unreachable or incorrect", file=sys.stderr)
        sys.exit(1)
    except Exception as err:
        print(f"‚ùå Webhook call error: {err}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        sys.exit(1)
    PY
    echo "Webhook called successfully"
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - if: $TRIGGER_DEPLOY == "true"
      when: on_success
    - when: manual
  allow_failure: false
