# Tests disabled by Infra Orchestrator (skip_tests enabled)
# Docker Application CI/CD Pipeline
# Auto-generated for containerized application

stages:
  - build
  - deploy

# Build using Azure Container Registry Tasks (builds in Azure, no disk space issues!)
# ACR Tasks build images directly in Azure infrastructure, bypassing GitLab runner limitations
build_to_acr:
  stage: build
  image: mcr.microsoft.com/azure-cli:latest
  variables:
    ACR_NAME: "irmaiuatregistry"
    ACR_REGISTRY: "irmaiuatregistry.azurecr.io"
    APP_NAME: "irmai-kg-v2-surrealdb"
    ACR_TASK_NAME: "irmai-kg-v2-surrealdb"
    ACR_RESOURCE_GROUP: "rg-irmai-uat-us-1"
    ORCHESTRATOR_URL: "https://b5cefeed5009.ngrok-free.app"
  before_script:
    - echo "=== Using Azure Container Registry Tasks ==="
    - 'echo "ACR: $ACR_REGISTRY"'
    - 'echo "Task: $ACR_TASK_NAME"'
    - 'echo "Image: $ACR_REGISTRY/$APP_NAME:$CI_COMMIT_SHORT_SHA"'
    - echo "Building in Azure (no GitLab runner disk space limitations!)"
    - |
      # Azure login - skip managed identity (not available on GitLab runners)
      # Use service principal directly
      if [ -z "$AZURE_CLIENT_ID" ] || [ -z "$AZURE_CLIENT_SECRET" ] || [ -z "$AZURE_TENANT_ID" ]; then
        echo "‚ùå Azure service principal credentials not set in GitLab CI/CD variables"
        echo "üí° Set AZURE_CLIENT_ID, AZURE_CLIENT_SECRET, AZURE_TENANT_ID in project settings"
        exit 1
      fi
      echo "üîê Logging in to Azure with service principal..."
      if ! az login --service-principal -u "$AZURE_CLIENT_ID" -p "$AZURE_CLIENT_SECRET" --tenant "$AZURE_TENANT_ID"; then
        echo "‚ùå Azure login failed"
        echo "üí° Check service principal credentials and permissions"
        exit 1
      fi
      echo "‚úÖ Azure login successful"
      # Quick permission test: Can we read ACR Task logs?
      echo "üîç Testing permissions: Can read ACR Task logs?"
      TEST_RUN_ID=$(az acr task list-runs --registry $ACR_NAME --resource-group $ACR_RESOURCE_GROUP --query '[0].runId' -o tsv 2>/dev/null || echo "")
      if [ -n "$TEST_RUN_ID" ]; then
        echo "Testing with latest run ID: $TEST_RUN_ID"
        TEST_LOGS=$(az acr task logs --registry $ACR_NAME --run-id $TEST_RUN_ID --resource-group $ACR_RESOURCE_GROUP 2>&1 || echo "FAILED")
        if echo "$TEST_LOGS" | grep -q "FAILED"; then
          echo "‚ö†Ô∏è  WARNING: Cannot read ACR Task logs - permission issue!"
          echo "   This may cause status check to fail even if build succeeds"
          echo "   Service principal may need 'AcrTaskReader' role"
        else
          echo "‚úÖ Can read ACR Task logs - permissions OK"
          echo "   Sample log format (last 3 lines):"
          echo "$TEST_LOGS" | tail -3 || echo "   (logs available but empty)"
        fi
      else
        echo "‚ÑπÔ∏è  No previous runs found to test permissions"
      fi
  script:
    - |
      # Build using Azure Container Registry Tasks (builds in Azure, no disk space issues!)
      # ACR Tasks build images directly in Azure infrastructure, bypassing GitLab runner limitations
      
      echo "üöÄ Triggering ACR Task to build image in Azure..."
      echo "This builds directly in Azure infrastructure (unlimited disk space!)"
      # Trigger ACR Task (builds with {.Run.ID} tag only)
      # IMPORTANT: Redirect stderr to avoid mixing logs with runId output
      # Use --no-logs to prevent streaming build logs to stdout
      # Strategy: Build with Run.ID tag, then retag with commit SHA after build completes
      echo "üîç Triggering ACR Task with parameters:"
      echo "   Task: $ACR_TASK_NAME"
      echo "   Registry: $ACR_NAME"
      echo "   GIT_REF: $CI_COMMIT_BRANCH"
      echo "   Strategy: Build with {.Run.ID} tag, retag with $CI_COMMIT_SHORT_SHA after build"
      
      # Capture both stdout and stderr to see the actual error
      # Note: We only pass GIT_REF, not COMMIT_SHA (ACR Task builds with {.Run.ID} only)
      RUN_ID_OUTPUT=$(az acr task run \
        --name $ACR_TASK_NAME \
        --registry $ACR_NAME \
        --resource-group $ACR_RESOURCE_GROUP \
        --set GIT_REF=$CI_COMMIT_BRANCH \
        --no-logs \
        --query 'runId' -o tsv 2>&1)
      RUN_ID_EXIT=$?
      
      echo "üìä az acr task run exit code: $RUN_ID_EXIT"
      echo "üìã Full output:"
      echo "$RUN_ID_OUTPUT" | while IFS= read -r line; do
        echo "   $line"
      done
      
      if [ $RUN_ID_EXIT -ne 0 ]; then
        echo "‚ùå Failed to trigger ACR Task"
        echo "   Exit code: $RUN_ID_EXIT"
        echo "   Error output: $RUN_ID_OUTPUT"
        echo ""
        echo "üí° Troubleshooting steps:"
        echo "   1. Verify ACR Task exists: az acr task show --name $ACR_TASK_NAME --registry $ACR_NAME --resource-group $ACR_RESOURCE_GROUP"
        echo "   2. Check if task is accessible: az acr task list --registry $ACR_NAME --resource-group $ACR_RESOURCE_GROUP"
        echo "   3. Verify service principal has permissions: az role assignment list --assignee $AZURE_CLIENT_ID"
        echo "   4. Run 'Update w/ ACR Tasks' in orchestrator UI to recreate the task"
        exit 1
      fi
      
      # Extract RUN_ID from output (might have warnings/error messages mixed in)
      # Run IDs are typically 3-4 character alphanumeric strings (e.g., 'cak', 'cah', 'car', 'cay', 'ca12')
      # The output might have warnings like "WARNING: Queued a run with ID: car" or just "car" on a line
      # Try multiple extraction methods:
      
      # Method 1: Look for "run with ID: XXX" pattern (extract ID after colon)
      RUN_ID=$(echo "$RUN_ID_OUTPUT" | grep -oE 'run with ID: [a-z0-9](3, 4)' | sed 's/.*: //' | head -1 || echo "")
      
      # Method 2: Look for "Queued a run with ID: XXX" pattern (extract ID after colon)
      if [ -z "$RUN_ID" ]; then
        RUN_ID=$(echo "$RUN_ID_OUTPUT" | grep -oE 'Queued a run with ID: [a-z0-9](3, 4)' | sed 's/.*: //' | head -1 || echo "")
      fi
      
      # Method 3: Look for standalone 3-4 character alphanumeric strings (most common)
      if [ -z "$RUN_ID" ]; then
        RUN_ID=$(echo "$RUN_ID_OUTPUT" | grep -oE '\b[a-z0-9](3, 4)\b' | head -1 || echo "")
      fi
      
      # Method 4: Look for any line that's just a 3-4 character alphanumeric string (trim whitespace)
      if [ -z "$RUN_ID" ]; then
        RUN_ID=$(echo "$RUN_ID_OUTPUT" | grep -xE '[a-z0-9](3, 4)' | head -1 | tr -d '[:space:]' || echo "")
      fi
      
      # Method 5: Extract from any line containing a 3-4 char alphanumeric string (fallback)
      if [ -z "$RUN_ID" ]; then
        # Look for patterns like "ID: ca13" or "ca13" anywhere
        RUN_ID=$(echo "$RUN_ID_OUTPUT" | grep -oE '[^a-z0-9][a-z0-9](3, 4)[^a-z0-9]' | grep -oE '[a-z0-9](3, 4)' | head -1 || echo "")
      fi
      
      # Method 6: Last resort - extract any 3-4 char alphanumeric from the last few lines
      if [ -z "$RUN_ID" ]; then
        RUN_ID=$(echo "$RUN_ID_OUTPUT" | tail -5 | grep -oE '[a-z0-9](3, 4)' | head -1 || echo "")
      fi
      
      if [ -z "$RUN_ID" ]; then
        echo "‚ùå Failed to extract Run ID from output"
        echo "   Output was:"
        echo "$RUN_ID_OUTPUT" | while IFS= read -r line; do
          echo "   $line"
        done
        echo "   Expected format: 3-4 character alphanumeric string (e.g., 'cak', 'car', 'ca12', 'ca13')"
        echo "   Tried multiple extraction methods - all failed"
        echo "   This might mean the task run failed or the output format changed"
        exit 1
      fi
      
      # Clean RUN_ID (remove any whitespace/newlines)
      RUN_ID=$(echo "$RUN_ID" | tr -d '[:space:]')
      
      echo "‚úÖ Extracted Run ID: $RUN_ID"
      
      echo "‚úÖ ACR Task triggered: Run ID $RUN_ID"
      
      echo "‚è≥ Waiting for build to complete..."
      # Wait for task to complete (max 20 minutes - builds typically take 10-15 minutes)
      # We check logs directly instead of relying on unreliable status API
      TIMEOUT=1200  # 20 minutes (reduced from 30 since builds take ~12 minutes)
      ELAPSED=0
      INTERVAL=10   # Check every 10 seconds
      LOG_CHECK_INTERVAL=30  # Check logs every 30 seconds
      LAST_LOG_CHECK=-30  # Start checking immediately (by setting to negative, first check happens at 0s)
      BUILD_COMPLETED=false
      
      echo "‚è≥ Waiting for build to complete (checking logs every 30s)..."
      echo "   Build typically takes 10-15 minutes"
      
      while [ $ELAPSED -lt $TIMEOUT ] && [ "$BUILD_COMPLETED" != "true" ]; do
        # PRIMARY METHOD: Check logs directly (more reliable than status API)
        # Check logs every 30 seconds (start immediately, not after 5 minutes)
        if [ $((ELAPSED - LAST_LOG_CHECK)) -ge $LOG_CHECK_INTERVAL ]; then
          LAST_LOG_CHECK=$ELAPSED
          
          echo ""
          echo "üîç Checking build logs for completion (elapsed: $ELAPSED seconds)..."
          echo "üìã Command: az acr task logs --registry $ACR_NAME --run-id $RUN_ID --resource-group $ACR_RESOURCE_GROUP"
          BUILD_LOGS=$(az acr task logs --registry $ACR_NAME --run-id $RUN_ID --resource-group $ACR_RESOURCE_GROUP 2>&1)
          LOGS_EXIT_CODE=$?
          
          echo "üìä Exit code: $LOGS_EXIT_CODE"
          
          if [ $LOGS_EXIT_CODE -ne 0 ]; then
            echo "‚ö†Ô∏è  Logs command failed (exit code: $LOGS_EXIT_CODE) - will retry"
            echo "   Full error output:"
            echo "$BUILD_LOGS"
          else
            LOGS_LENGTH=$(echo "$BUILD_LOGS" | wc -c)
            echo "üìè Logs length: $LOGS_LENGTH characters"
            
            # Show what we actually got (last 30 lines for context)
            echo "üìÑ Raw log output (last 30 lines):"
            echo "---START OF LOGS---"
            echo "$BUILD_LOGS" | tail -30
            echo "---END OF LOGS---"
            
            # Check for success - MULTIPLE patterns to catch all success indicators
            # Pattern 1: "Run ID: <id> was successful" (most common)
            # Pattern 2: "was successful after" (with timing)
            # Pattern 3: "Step ID: push marked as successful" (final step)
            # Pattern 4: "Successfully pushed image" (image push success)
            echo "üîç Searching for success indicators in logs..."
            SUCCESS_MATCH=$(echo "$BUILD_LOGS" | grep -iE "was successful|marked as successful|Successfully pushed image|Step ID.*marked as successful" || echo "")
            if [ -n "$SUCCESS_MATCH" ]; then
              echo "‚úÖ‚úÖ‚úÖ BUILD SUCCEEDED - Found success indicator in logs!"
              echo "   Matching line(s):"
              echo "$SUCCESS_MATCH" | head -5
              BUILD_COMPLETED=true
              break  # Exit while loop immediately
            else
              echo "   ‚ùå No success indicators found in logs yet"
            fi
            
            # Check for failure
            FAILURE_MATCH=$(echo "$BUILD_LOGS" | grep -iE "failed|error.*exit|Step ID.*marked as failed" || echo "")
            if [ -n "$FAILURE_MATCH" ]; then
              echo "‚ùå Build failed according to logs"
              echo "   Failure indicators:"
              echo "$FAILURE_MATCH" | tail -5
              exit 1
            fi
            
            # Show progress
            if [ "$LOGS_LENGTH" -gt 0 ]; then
              echo "   ‚ÑπÔ∏è  Logs available but no clear success/failure indicator yet"
              echo "   Build may still be running..."
            else
              echo "   ‚ö†Ô∏è  Logs empty - build may still be starting"
            fi
          fi
        fi
        
        # SECONDARY METHOD: Try status API (less reliable, but good for early detection)
        # Only check status every 30 seconds to avoid API rate limits
        if [ $((ELAPSED % 30)) -eq 0 ]; then
          STATUS_OUTPUT=$(az acr task show-run \
            --registry $ACR_NAME \
            --run-id $RUN_ID \
            --resource-group $ACR_RESOURCE_GROUP \
            --query 'status' -o tsv 2>&1)
          STATUS_EXIT_CODE=$?
          STATUS=$(echo "$STATUS_OUTPUT" | head -n 1 | tr -d '[:space:]')
          
          if [ $STATUS_EXIT_CODE -eq 0 ] && [ -n "$STATUS" ] && [ "$STATUS" != "" ]; then
            echo "üìä Status API: $STATUS (elapsed: $ELAPSED seconds)"
            
            # If status API says succeeded, trust it
            if [ "$STATUS" = "Succeeded" ] || [ "$STATUS" = "succeeded" ] || [ "$STATUS" = "SUCCEEDED" ]; then
              echo "‚úÖ Build completed successfully (from status API)!"
              exit 0
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "failed" ] || [ "$STATUS" = "FAILED" ]; then
              echo "‚ùå Build failed (from status API)"
              az acr task logs --registry $ACR_NAME --run-id $RUN_ID --resource-group $ACR_RESOURCE_GROUP || true
              exit 1
            fi
          else
            # Status API unreliable - that's OK, we're checking logs
            if [ $ELAPSED -lt 60 ]; then
              echo "üìä Status API: Unknown/unavailable (will check logs every 30s)"
            fi
          fi
        fi
        
        sleep $INTERVAL
        ELAPSED=$((ELAPSED + INTERVAL))
      done
      
      # If build completed successfully, exit now
      if [ "$BUILD_COMPLETED" = "true" ]; then
        echo ""
        echo "‚úÖ Build completed successfully during polling!"
        exit 0
      fi
      
      echo ""
      echo "‚è∞ Timeout reached after $TIMEOUT seconds (20 minutes)"
      echo "üîç Final check: Reading build logs to determine actual status..."
      
      # FINAL CHECK: Logs are the source of truth
      echo "üìã Command: az acr task logs --registry $ACR_NAME --run-id $RUN_ID --resource-group $ACR_RESOURCE_GROUP"
      BUILD_LOGS=$(az acr task logs --registry $ACR_NAME --run-id $RUN_ID --resource-group $ACR_RESOURCE_GROUP 2>&1)
      LOGS_EXIT_CODE=$?
      
      echo "üìä Exit code: $LOGS_EXIT_CODE"
      
      if [ $LOGS_EXIT_CODE -ne 0 ]; then
        echo "‚ùå Cannot read logs (exit code: $LOGS_EXIT_CODE)"
        echo "   This may indicate permission issues"
        echo "   Full error output:"
        echo "$BUILD_LOGS"
        exit 1
      fi
      
      LOGS_LENGTH=$(echo "$BUILD_LOGS" | wc -c)
      echo "üìè Logs length: $LOGS_LENGTH characters"
      
      # Show FULL raw output so we can see exactly what we got
      echo "üìÑ FULL RAW LOG OUTPUT:"
      echo "=========================================="
      echo "$BUILD_LOGS"
      echo "=========================================="
      
      # CRITICAL: Multiple success patterns to catch all success indicators
      # This is the FINAL check - must be comprehensive
      echo ""
      echo "üîç FINAL CHECK: Searching for ALL success indicators in logs..."
      echo "   Patterns: 'was successful', 'marked as successful', 'Successfully pushed image'"
      
      # Try multiple patterns - any one indicates success
      SUCCESS_PATTERN1=$(echo "$BUILD_LOGS" | grep -i "was successful" || echo "")
      SUCCESS_PATTERN2=$(echo "$BUILD_LOGS" | grep -i "marked as successful" || echo "")
      SUCCESS_PATTERN3=$(echo "$BUILD_LOGS" | grep -i "Successfully pushed image" || echo "")
      SUCCESS_PATTERN4=$(echo "$BUILD_LOGS" | grep -iE "Step ID.*successful|Step ID.*marked as successful" || echo "")
      
      if [ -n "$SUCCESS_PATTERN1" ] || [ -n "$SUCCESS_PATTERN2" ] || [ -n "$SUCCESS_PATTERN3" ] || [ -n "$SUCCESS_PATTERN4" ]; then
        echo "‚úÖ‚úÖ‚úÖ BUILD SUCCEEDED - Found success indicator(s) in logs!"
        if [ -n "$SUCCESS_PATTERN1" ]; then
          echo "   Pattern 1 (was successful):"
          echo "$SUCCESS_PATTERN1" | head -3
        fi
        if [ -n "$SUCCESS_PATTERN2" ]; then
          echo "   Pattern 2 (marked as successful):"
          echo "$SUCCESS_PATTERN2" | head -3
        fi
        if [ -n "$SUCCESS_PATTERN3" ]; then
          echo "   Pattern 3 (Successfully pushed):"
          echo "$SUCCESS_PATTERN3" | head -3
        fi
        if [ -n "$SUCCESS_PATTERN4" ]; then
          echo "   Pattern 4 (Step ID successful):"
          echo "$SUCCESS_PATTERN4" | head -3
        fi
        exit 0
      else
        echo "   ‚ùå NO success indicators found in logs"
        echo "   Searched for: 'was successful', 'marked as successful', 'Successfully pushed image', 'Step ID.*successful'"
      fi
      
      # Check for failure
      FAILURE_MATCH=$(echo "$BUILD_LOGS" | grep -iE "failed|error.*exit" || echo "")
      if [ -n "$FAILURE_MATCH" ]; then
        echo "‚ùå Build failed according to logs"
        echo "   Failure indicators:"
        echo "$FAILURE_MATCH" | tail -10
        exit 1
      fi
      
      # If we can't determine, show logs and fail
      echo "‚ùå Could not determine build status from logs"
      echo "   Full log output shown above - please check if 'was successful' appears"
      echo "   If it does appear, this is a bug - please report"
      exit 1
      
      # This code is unreachable but kept for structure
      # The exit above will prevent reaching here
      echo "‚úÖ Build completed! Now retagging with commit SHA..."
      echo "üìã Retagging strategy: Get image digest from Run.ID tag, add commit SHA tag"
      # ACR Task built image with {.Run.ID} tag only
      # Now we need to retag it with commit SHA for deployment
      # Strategy: Use ACR REST API or az acr import to add commit SHA tag
      
      echo "üîç Step 1: Getting image digest for Run.ID tag '$RUN_ID'..."
      echo "   Querying ACR for manifests with tag '$RUN_ID'..."
      
      # Try multiple query approaches - tag might be in different positions
      # First try: tag is first in tags array
      DIGEST=$(az acr repository show-manifests \
        --name $ACR_NAME \
        --repository $APP_NAME \
        --query "[?tags[0]=='$RUN_ID'].digest" -o tsv 2>&1)
      DIGEST_EXIT=$?
      
      # If that didn't work, try: tag exists anywhere in tags array
      if [ $DIGEST_EXIT -ne 0 ] || [ -z "$DIGEST" ]; then
        echo "   First query failed, trying alternative query (tag anywhere in tags array)..."
        DIGEST=$(az acr repository show-manifests \
          --name $ACR_NAME \
          --repository $APP_NAME \
          --query "[?contains(tags, '$RUN_ID')].digest" -o tsv 2>&1)
        DIGEST_EXIT=$?
      fi
      
      # If still no digest, try getting all manifests and filtering manually
      if [ $DIGEST_EXIT -ne 0 ] || [ -z "$DIGEST" ]; then
        echo "   Alternative query failed, trying manual filtering..."
        ALL_MANIFESTS=$(az acr repository show-manifests \
          --name $ACR_NAME \
          --repository $APP_NAME \
          --output json 2>&1)
        if [ $? -eq 0 ]; then
          # Use python to find manifest with the tag (use jq or simple grep as fallback to avoid YAML issues)
          # Try jq first (more reliable)
          if command -v jq >/dev/null 2>&1; then
            DIGEST=$(echo "$ALL_MANIFESTS" | jq -r ".[] | select(.tags[]? == "$RUN_ID") | .digest" | head -1)
          else
            # Fallback: Use simple grep to find the tag, then extract digest from that line
            # This avoids complex Python code in YAML
            TAG_LINE=$(echo "$ALL_MANIFESTS" | grep -o ""$RUN_ID"" -B 5 | grep digest | head -1)
            if [ -n "$TAG_LINE" ]; then
              DIGEST=$(echo "$TAG_LINE" | grep -o '"digest":"[^"]*"' | cut -d'"' -f4)
            fi
          fi
          if [ -n "$DIGEST" ]; then
            DIGEST_EXIT=0
          fi
        fi
      fi
      
      if [ $DIGEST_EXIT -ne 0 ] || [ -z "$DIGEST" ]; then
        echo "‚ùå‚ùå‚ùå CRITICAL: Failed to get image digest for Run.ID tag '$RUN_ID'"
        echo "   Exit code: $DIGEST_EXIT"
        echo "   Output: $DIGEST"
        echo ""
        echo "üîç Debugging: Listing all available manifests..."
        az acr repository show-manifests \
          --name $ACR_NAME \
          --repository $APP_NAME \
          --output table 2>&1 | head -20
        echo ""
        echo "üí° This means:"
        echo "   1. The build may have failed (image doesn't exist)"
        echo "   2. The Run.ID tag format is different than expected"
        echo "   3. ACR query syntax issue"
        echo ""
        echo "‚ùå FAILING JOB - Cannot retag without digest"
        exit 1
      fi
      
      echo "‚úÖ Found image digest: $DIGEST"
      echo ""
      echo "üîç Step 2: Adding commit SHA tag using az acr import..."
      
      # Use az acr import to retag (same-registry import)
      SOURCE_IMAGE="$ACR_REGISTRY/$APP_NAME:$RUN_ID"
      TARGET_IMAGE="$APP_NAME:$CI_COMMIT_SHORT_SHA"
      
      echo "   Source: $SOURCE_IMAGE"
      echo "   Target: $TARGET_IMAGE"
      
      IMPORT_OUTPUT=$(az acr import \
        --name $ACR_NAME \
        --source $SOURCE_IMAGE \
        --image $TARGET_IMAGE \
        --resource-group $ACR_RESOURCE_GROUP 2>&1)
      IMPORT_EXIT=$?
      
      if [ $IMPORT_EXIT -ne 0 ]; then
        echo "‚ùå az acr import failed (exit code: $IMPORT_EXIT)"
        echo "   This is expected for same-registry imports - trying alternative method..."
        echo "   Output: $IMPORT_OUTPUT"
        echo ""
        echo "üîç Step 2 (Alternative): Using ACR REST API to add tag..."
        
        # Alternative: Use ACR REST API via curl
        # Get access token
        echo "   Getting ACR access token..."
        TOKEN=$(az acr login --name $ACR_NAME --expose-token --output tsv --query accessToken 2>&1)
        if [ $? -ne 0 ] || [ -z "$TOKEN" ]; then
          echo "‚ùå Failed to get ACR access token"
          echo "   Token output: $TOKEN"
          echo "   Will continue anyway - deployment may fail if tag doesn't exist"
        else
          TOKEN_LENGTH=$(echo -n "$TOKEN" | wc -c)
          echo "   ‚úÖ Got access token (length: $TOKEN_LENGTH)"
          
          # Get manifest
          ACR_SERVER="$ACR_NAME.azurecr.io"
          echo "   Getting manifest from digest..."
          echo "   ACR Server: $ACR_SERVER"
          echo "   Image: $APP_NAME"
          echo "   Digest: $DIGEST"
          echo "   URL: https://$ACR_SERVER/v2/$APP_NAME/manifests/$DIGEST"
          
          # Get manifest - use digest directly (not tag)
          # Save response headers and body separately
          TEMP_DIR=$(mktemp -d)
          MANIFEST_HEADERS="$TEMP_DIR/manifest_headers.txt"
          MANIFEST_BODY="$TEMP_DIR/manifest_body.json"
          
          echo "   Fetching manifest (saving headers and body separately)..."
          curl -s -D "$MANIFEST_HEADERS" -o "$MANIFEST_BODY" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Accept: application/vnd.docker.distribution.manifest.v2+json,application/vnd.oci.image.manifest.v1+json" \
            "https://$ACR_SERVER/v2/$APP_NAME/manifests/$DIGEST" 2>&1
          
          HTTP_CODE=$(grep "^HTTP" "$MANIFEST_HEADERS" | tail -1 | awk '{print $2}' || echo "000")
          CONTENT_TYPE=$(grep -i "^content-type:" "$MANIFEST_HEADERS" | cut -d: -f2 | tr -d ' ' || echo "application/vnd.docker.distribution.manifest.v2+json")
          DOCKER_DIGEST=$(grep -i "^docker-content-digest:" "$MANIFEST_HEADERS" | cut -d: -f2 | tr -d ' ' || echo "")
          
          echo "   GET manifest HTTP code: $HTTP_CODE"
          echo "   Content-Type: $CONTENT_TYPE"
          if [ -n "$DOCKER_DIGEST" ]; then
            echo "   Docker-Content-Digest: $DOCKER_DIGEST"
          fi
          
          if [ "$HTTP_CODE" = "200" ]; then
            MANIFEST_SIZE=$(wc -c < "$MANIFEST_BODY")
            echo "   ‚úÖ Got manifest (HTTP $HTTP_CODE, size: $MANIFEST_SIZE bytes)"
            
            # Verify manifest is valid JSON
            if ! python3 -m json.tool "$MANIFEST_BODY" > /dev/null 2>&1; then
              echo "   ‚ö†Ô∏è  Warning: Manifest body is not valid JSON"
              echo "   First 100 chars: $(head -c 100 "$MANIFEST_BODY")"
            fi
            
            # Put manifest with new tag (use the tag as reference, not digest)
            echo "   Putting manifest with commit SHA tag..."
            echo "   Target tag: $CI_COMMIT_SHORT_SHA"
            echo "   URL: https://$ACR_SERVER/v2/$APP_NAME/manifests/$CI_COMMIT_SHORT_SHA"
            
            PUT_HEADERS="$TEMP_DIR/put_headers.txt"
            PUT_BODY="$TEMP_DIR/put_body.txt"
            
            curl -s -D "$PUT_HEADERS" -o "$PUT_BODY" -X PUT \
              -H "Authorization: Bearer $TOKEN" \
              -H "Content-Type: $CONTENT_TYPE" \
              --data-binary "@$MANIFEST_BODY" \
              "https://$ACR_SERVER/v2/$APP_NAME/manifests/$CI_COMMIT_SHORT_SHA" 2>&1
            
            PUT_HTTP_CODE=$(grep "^HTTP" "$PUT_HEADERS" | tail -1 | awk '{print $2}' || echo "000")
            PUT_RESPONSE_BODY=$(cat "$PUT_BODY")
            
            echo "   PUT manifest HTTP code: $PUT_HTTP_CODE"
            
            # Cleanup temp files
            rm -rf "$TEMP_DIR"
            
            if [ "$PUT_HTTP_CODE" = "201" ] || [ "$PUT_HTTP_CODE" = "200" ]; then
              echo "‚úÖ‚úÖ‚úÖ Successfully added commit SHA tag using REST API!"
              echo "   Tag: $CI_COMMIT_SHORT_SHA"
              echo "   HTTP code: $PUT_HTTP_CODE"
              REST_API_SUCCESS=true
            else
              echo "‚ùå REST API PUT returned HTTP $PUT_HTTP_CODE (expected 200 or 201)"
              echo "   Full response:"
              echo "$PUT_RESPONSE_BODY" | head -30
              echo ""
              echo "   Common issues:"
              echo "   - HTTP 401: Authentication failed (token expired or invalid)"
              echo "   - HTTP 404: Repository or digest not found"
              echo "   - HTTP 400: Bad request (manifest format issue)"
              echo "   - HTTP 405: Method not allowed"
              REST_API_SUCCESS=false
            fi
          else
            echo "‚ùå Failed to get manifest (HTTP $HTTP_CODE, expected 200)"
            echo "   Full response:"
            echo "$MANIFEST_BODY" | head -30
            echo ""
            echo "   Common issues:"
            echo "   - HTTP 401: Authentication failed"
            echo "   - HTTP 404: Digest not found"
            echo "   - HTTP 400: Bad request"
            REST_API_SUCCESS=false
          fi
        fi
        
        # If REST API also failed, we have a problem
        if [ "$REST_API_SUCCESS" != "true" ]; then
          echo ""
          echo "‚ùå Both az acr import and REST API failed!"
          echo "   This is a critical issue - image cannot be tagged with commit SHA"
          echo "   The build job will fail because deployment requires this tag"
        fi
      else
        echo "‚úÖ‚úÖ‚úÖ Successfully added commit SHA tag using az acr import!"
        echo "   Tag: $CI_COMMIT_SHORT_SHA"
        IMPORT_SUCCESS=true
      fi
      
      # If import failed, REST_API_SUCCESS will be checked in verification step
      
      echo ""
      echo "üîç Step 3: Verifying both tags exist..."
      sleep 3  # Wait for ACR to process the tag
      
      # Verify Run.ID tag exists
      RUN_ID_TAGS=$(az acr repository show-tags \
        --name $ACR_NAME \
        --repository $APP_NAME \
        --query "[?name=='$RUN_ID'].name" -o tsv 2>&1)
      
      # Verify commit SHA tag exists
      COMMIT_TAGS=$(az acr repository show-tags \
        --name $ACR_NAME \
        --repository $APP_NAME \
        --query "[?name=='$CI_COMMIT_SHORT_SHA'].name" -o tsv 2>&1)
      
      echo "   Run.ID tag '$RUN_ID': $(echo "$RUN_ID_TAGS" | grep -q "$RUN_ID" && echo "‚úÖ EXISTS" || echo "‚ùå NOT FOUND")"
      echo "   Commit SHA tag '$CI_COMMIT_SHORT_SHA': $(echo "$COMMIT_TAGS" | grep -q "$CI_COMMIT_SHORT_SHA" && echo "‚úÖ EXISTS" || echo "‚ùå NOT FOUND")"
      
      if echo "$COMMIT_TAGS" | grep -q "$CI_COMMIT_SHORT_SHA"; then
        echo ""
        echo "‚úÖ‚úÖ‚úÖ SUCCESS: Commit SHA tag verified!"
        echo "   Image ready for deployment: $ACR_REGISTRY/$APP_NAME:$CI_COMMIT_SHORT_SHA"
        echo ""
        echo "‚úÖ Retagging complete!"
      else
        echo ""
        echo "‚ùå‚ùå‚ùå CRITICAL FAILURE: Commit SHA tag NOT FOUND after retagging!"
        echo "   Expected tag: $CI_COMMIT_SHORT_SHA"
        echo "   Found tags: $COMMIT_TAGS"
        echo "   Run.ID tag exists: $(echo "$RUN_ID_TAGS" | grep -q "$RUN_ID" && echo "YES" || echo "NO")"
        echo ""
        echo "üí° This means retagging failed - deployment will fail!"
        echo "   Possible causes:"
        echo "   1. az acr import failed (same-registry import not supported)"
        echo "   2. ACR REST API failed (permissions, network, etc.)"
        echo "   3. ACR is still processing (unlikely after 3s wait)"
        echo ""
        echo "üîç Debugging info:"
        echo "   ACR: $ACR_NAME"
        echo "   Image: $APP_NAME"
        echo "   Run.ID: $RUN_ID"
        echo "   Digest: $DIGEST"
        echo "   Commit SHA: $CI_COMMIT_SHORT_SHA"
        echo ""
        echo "‚ùå FAILING JOB - Image cannot be deployed without commit SHA tag"
        exit 1
      fi
      
      echo "‚úÖ Image built and tagged in Azure: $ACR_REGISTRY/$APP_NAME:$CI_COMMIT_SHORT_SHA"
  rules:
    - if: $CI_COMMIT_BRANCH
      exists:
        - Dockerfile



# Deployment job added by Infrastructure Orchestrator
# Calls our platform's webhook to deploy (our platform has AKS access!)
# Auto-runs on main branch or when triggered from UI

deploy_to_infrastructure:
  stage: deploy
  image: alpine:3.19
  before_script: []
  variables:
    DEPLOY_TARGET: "kubernetes"
    K8S_CLUSTER: "rg-irmai-uat-us-1-cluster"
    DEPLOY_NAMESPACE: "default"
    RESOURCE_GROUP: "rg-irmai-uat-us-1"
    ORCHESTRATOR_URL: "https://b5cefeed5009.ngrok-free.app"
    DEPLOY_IMAGE: "irmaiuatregistry.azurecr.io/irmai-kg-v2-surrealdb:$CI_COMMIT_SHORT_SHA"
  script: |
    echo "=== Deployment to Infrastructure ==="
    echo "Image: $DEPLOY_IMAGE"
    echo "Cluster: $K8S_CLUSTER"
    echo "Namespace: $DEPLOY_NAMESPACE"
    echo "Resource Group: $RESOURCE_GROUP"
    echo ""
    
    # Install required tools
    if ! command -v curl >/dev/null 2>&1; then
      echo "üì¶ Installing curl (alpine)..."
      apk add --no-cache curl >/tmp/curl-install.log 2>&1 || { echo "‚ùå Failed to install curl"; cat /tmp/curl-install.log; exit 1; }
    fi
    if ! command -v python3 >/dev/null 2>&1; then
      echo "üì¶ Installing python3 (alpine)..."
      apk add --no-cache python3 >/tmp/python-install.log 2>&1 || { echo "‚ùå Failed to install python3"; cat /tmp/python-install.log; exit 1; }
    fi
    
    # Step 1: Verify image exists in ACR (if it's an ACR image)
    if echo "$DEPLOY_IMAGE" | grep -q "\.azurecr\.io"; then
      echo ""
      echo "üîç Step 1: Verifying image exists in ACR..."
      ACR_REGISTRY=$(echo "$DEPLOY_IMAGE" | cut -d'/' -f1)
      IMAGE_WITH_TAG=$(echo "$DEPLOY_IMAGE" | cut -d'/' -f2-)
      IMAGE_NAME=$(echo "$IMAGE_WITH_TAG" | cut -d':' -f1)
      IMAGE_TAG=$(echo "$IMAGE_WITH_TAG" | cut -d':' -f2)
      ACR_NAME=$(echo "$ACR_REGISTRY" | cut -d'.' -f1)
      
      echo "   ACR: $ACR_NAME"
      echo "   Image: $IMAGE_NAME"
      echo "   Tag: $IMAGE_TAG"
      echo "   Full: $DEPLOY_IMAGE"
      
      # Check if we have Azure CLI available (for ACR checks)
      if command -v az >/dev/null 2>&1; then
        echo "   Using Azure CLI to verify image..."
        MAX_RETRIES=3
        RETRY_DELAY=5
        IMAGE_EXISTS=false
        
        for i in $(seq 1 $MAX_RETRIES); do
          echo "   Attempt $i/$MAX_RETRIES: Checking if tag exists..."
          TAG_CHECK=$(az acr repository show-tags \
            --name "$ACR_NAME" \
            --repository "$IMAGE_NAME" \
            --query "[?name=='$IMAGE_TAG'].name" -o tsv 2>&1)
          TAG_CHECK_EXIT=$?
          
          if [ $TAG_CHECK_EXIT -eq 0 ] && echo "$TAG_CHECK" | grep -q "$IMAGE_TAG"; then
            echo "   ‚úÖ Image tag found: $IMAGE_TAG"
            IMAGE_EXISTS=true
            break
          else
            echo "   ‚ö†Ô∏è  Tag not found (attempt $i/$MAX_RETRIES)"
            echo "   Output: $TAG_CHECK"
            if [ $i -lt $MAX_RETRIES ]; then
              echo "   ‚è≥ Waiting $RETRY_DELAY seconds before retry (ACR might still be processing)..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))  # Exponential backoff
            fi
          fi
        done
        
        if [ "$IMAGE_EXISTS" != "true" ]; then
          echo ""
          echo "‚ùå‚ùå‚ùå CRITICAL: Image tag '$IMAGE_TAG' NOT FOUND in ACR after $MAX_RETRIES attempts!"
          echo "   Expected image: $DEPLOY_IMAGE"
          echo "   ACR: $ACR_NAME"
          echo "   Repository: $IMAGE_NAME"
          echo ""
          echo "üí° Possible causes:"
          echo "   1. build_to_acr job failed or didn't complete"
          echo "   2. Image retagging failed (check build_to_acr job logs)"
          echo "   3. ACR is still processing the tag (unlikely after $MAX_RETRIES attempts)"
          echo "   4. Wrong tag name (check build_to_acr job for actual tag used)"
          echo ""
          echo "üîç Checking what tags DO exist in ACR..."
          ALL_TAGS=$(az acr repository show-tags --name "$ACR_NAME" --repository "$IMAGE_NAME" --query "[].name" -o tsv 2>&1 || echo "Failed to list tags")
          echo "   Available tags:"
          echo "$ALL_TAGS" | head -10 | while read tag; do
            echo "     - $tag"
          done
          if [ $(echo "$ALL_TAGS" | wc -l) -gt 10 ]; then
            echo "     ... (showing first 10, more exist)"
          fi
          echo ""
          echo "‚ö†Ô∏è  Deployment will likely fail, but continuing to show actual error from orchestrator"
        fi
      else
        echo "   ‚ö†Ô∏è  Azure CLI not available, skipping image verification"
        echo "   Will proceed with deployment (orchestrator will show error if image doesn't exist)"
      fi
    else
      echo ""
      echo "‚ÑπÔ∏è  Image is not from ACR (or format not recognized), skipping ACR verification"
      echo "   Image: $DEPLOY_IMAGE"
    fi
    
    echo ""
    echo "üîó Step 2: Calling Infrastructure Orchestrator webhook..."
    python3 - <<'PY'
    import json
    import os
    import sys
    import urllib.error
    import urllib.request
    from pathlib import Path

    url_base = os.environ.get("ORCHESTRATOR_URL")
    if not url_base:
        print("‚ùå ORCHESTRATOR_URL is not set", file=sys.stderr)
        print("   Please set ORCHESTRATOR_URL in GitLab CI/CD variables", file=sys.stderr)
        sys.exit(1)
    
    # Validate URL format
    url_base = url_base.rstrip("/")
    if not url_base.startswith(("http://", "https://")):
        print(f"‚ùå Invalid ORCHESTRATOR_URL format: {url_base}", file=sys.stderr)
        print("   ORCHESTRATOR_URL must start with http:// or https://", file=sys.stderr)
        sys.exit(1)
    
    print(f"üìç Using ORCHESTRATOR_URL: {url_base}")

    def _branch_for_release() -> str:
        branch = (
            os.environ.get("CI_COMMIT_BRANCH")
            or os.environ.get("CI_COMMIT_REF_NAME")
            or os.environ.get("CI_COMMIT_TAG")
            or os.environ.get("CI_DEFAULT_BRANCH")
            or ""
        )
        return branch or "main"

    payload_path = Path("payload.json")
    if payload_path.exists():
        payload = json.loads(payload_path.read_text() or "{}")
    else:
        commit_sha = os.environ.get("CI_COMMIT_SHORT_SHA", "")
        deploy_image = os.environ.get("DEPLOY_IMAGE", "")
        print(f"üîç Debug: CI_COMMIT_SHORT_SHA={commit_sha}")
        print(f"üîç Debug: DEPLOY_IMAGE (raw)={deploy_image}")
        # Resolve $CI_COMMIT_SHORT_SHA in DEPLOY_IMAGE if GitLab didn't resolve it
        if deploy_image and "$CI_COMMIT_SHORT_SHA" in deploy_image:
            deploy_image = deploy_image.replace("$CI_COMMIT_SHORT_SHA", commit_sha)
            print(f"üîç Debug: DEPLOY_IMAGE (resolved)={deploy_image}")
        payload = {
            "project_id": os.environ.get("CI_PROJECT_ID"),
            "project_name": os.environ.get("CI_PROJECT_NAME"),
            "image": deploy_image,
            "cluster_name": os.environ.get("K8S_CLUSTER"),
            "namespace": os.environ.get("DEPLOY_NAMESPACE"),
            "resource_group": os.environ.get("RESOURCE_GROUP"),
            "branch": "",
            "commit_sha": commit_sha,
        }

        services_json = os.environ.get("MULTI_SERVICE_CONFIG_JSON") or ""
        strategy_value = os.environ.get("DEPLOYMENT_STRATEGY") or ""
        if services_json:
            commit_sha = commit_sha or os.environ.get("CI_COMMIT_SHORT_SHA", "")
            rendered = services_json.replace("{{CI_COMMIT_SHORT_SHA}}", commit_sha)
            try:
                payload["services"] = json.loads(rendered)
            except json.JSONDecodeError as exc:
                print(f"‚ùå Failed to parse MULTI_SERVICE_CONFIG_JSON: {exc}", file=sys.stderr)
                sys.exit(1)
            payload["deployment_strategy"] = strategy_value or "helm_multi_service"
        
        # Read static IP configuration from CI variables if provided
        static_ip_json = os.environ.get("STATIC_IP_CONFIG_JSON") or ""
        if static_ip_json:
            try:
                payload["static_ip_config"] = json.loads(static_ip_json)
            except json.JSONDecodeError as exc:
                print(f"‚ö†Ô∏è  Failed to parse STATIC_IP_CONFIG_JSON: {exc}", file=sys.stderr)
                # Don't fail deployment if static IP config is invalid, just log warning

    payload.setdefault("commit_sha", os.environ.get("CI_COMMIT_SHORT_SHA", ""))
    payload["branch"] = payload.get("branch") or _branch_for_release()

    data = json.dumps(payload).encode()
    payload_path.write_bytes(data)

    url = url_base + "/webhooks/gitlab-deploy"
    print(f"üîó Calling webhook: {url}")
    print(f"üì¶ Payload: {json.dumps(json.loads(data.decode()), indent=2)}")

    req = urllib.request.Request(
        url,
        data=data,
        headers={"Content-Type": "application/json"},
        method="POST",
    )

    try:
        with urllib.request.urlopen(req, timeout=600) as resp:
            body = resp.read().decode() if resp.length != 0 else ""
            print(f"‚úÖ Webhook response status: {resp.status}")
            if body:
                try:
                    parsed = json.loads(body)
                    print(json.dumps(parsed, indent=2))
                except json.JSONDecodeError:
                    print(body)
    except urllib.error.HTTPError as exc:
        print(f"‚ùå Webhook call failed with status {exc.code}: {exc.reason}", file=sys.stderr)
        print(f"   URL: {url}", file=sys.stderr)
        try:
            error_body = exc.read().decode()
            if error_body:
                print(f"   Error details: {error_body}", file=sys.stderr)
                try:
                    error_json = json.loads(error_body)
                    if "detail" in error_json:
                        print(f"   Detail: {error_json['detail']}", file=sys.stderr)
                except json.JSONDecodeError:
                    pass
        except Exception:
            pass
        
        # Provide helpful error message for 404
        if exc.code == 404:
            print("", file=sys.stderr)
            print("üí° Troubleshooting:", file=sys.stderr)
            print("   1. Check ORCHESTRATOR_URL is set correctly in GitLab CI/CD variables", file=sys.stderr)
            print("   2. Verify the URL is accessible from GitLab CI runners", file=sys.stderr)
            print("   3. Ensure the API server is running and accessible", file=sys.stderr)
            print(f"   4. Expected endpoint: {url_base}/webhooks/gitlab-deploy", file=sys.stderr)
        
        sys.exit(exc.code if isinstance(exc.code, int) else 1)
    except urllib.error.URLError as url_err:
        print(f"‚ùå Webhook URL error: {url_err}", file=sys.stderr)
        print(f"   URL: {url}", file=sys.stderr)
        print("   This usually means the URL is unreachable or incorrect", file=sys.stderr)
        sys.exit(1)
    except Exception as err:
        print(f"‚ùå Webhook call error: {err}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        sys.exit(1)
    PY
    echo "Webhook called successfully"
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - if: $TRIGGER_DEPLOY == "true"
      when: on_success
    - when: manual
  allow_failure: false
